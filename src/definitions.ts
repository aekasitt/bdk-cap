/* ~~/src/definitions.ts */

declare module '@capacitor/core' {
  interface PluginRegistry {
    KruttCapacitorBDK: KruttCapacitorBDKPlugin
  }
}

// import { PluginResultError } from '@capacitor/core';

/******************************/
/**           Enums          **/
/******************************/

export enum WordCount {
  WORDS12 = 12,
  WORDS15 = 15,
  WORDS18 = 18,
  WORDS21 = 21,
  WORDS24 = 24,
}

export enum Network {
  Testnet = 'testnet',
  Regtest = 'regtest',
  Bitcoin = 'bitcoin',
  Signet = 'signet',
}

export enum EntropyLength {
  Length16 = 16,
  Length24 = 24,
  Length32 = 32,
}

export enum BlockChainNames {
  Electrum = 'Electrum',
  Esplora = 'Esplora',
  Rpc = 'Rpc',
}

export enum AddressIndex {
  New = 'new',
  LastUnused = 'lastUnused',
}

export enum KeychainKind {
  External = 'external',
  Internal = 'internal',
}

export interface BlockchainElectrumConfig {
  url: string
  sock5: string | null
  retry: number
  timeout: number
  stopGap: number
  validateDomain: boolean
}
export interface BlockchainEsploraConfig {
  baseUrl: string
  proxy: string | null
  concurrency: number
  stopGap: number
  timeout: number
}

export interface UserPass {
  username: string
  password: string
}
export interface RpcSyncParams {
  startScriptCount: number
  startTime: number
  forceStartTime: boolean
  pollRateSec: number
}

export interface BlockchainRpcConfig {
  url: string
  authCookie?: string
  authUserPass?: UserPass
  network: Network
  walletName: string
  syncParams?: RpcSyncParams
}

export interface Payload {
  type: string
  value: Array<number>
  version?: string
}

/******************************/
/**         Bindings         **/
/******************************/

/**
 * A reference to a transaction output.
 */
export class OutPoint {
  /**
   * The referenced transaction's txid.
   */
  txid: string

  /**
   * The index of the referenced output in its transaction's vout.
   */
  vout: number

  constructor(txid: string, vout: number) {
    this.txid = txid
    this.vout = vout
  }
}

export class Balance {
  /**
   * Unconfirmed UTXOs generated by a wallet tx
   */
  trustedPending: number

  /**
   * Unconfirmed UTXOs received from an external wallet
   */
  untrustedPending: number

  /**
   * Confirmed and immediately spendable balance
   */
  confirmed: number

  /**
   * Get sum of trusted_pending and confirmed coins
   */
  spendable: number

  /**
   * Get the whole balance visible to the wallet
   */
  total: number

  constructor(
    trustedPending: number,
    untrustedPending: number,
    confirmed: number,
    spendable: number,
    total: number
  ) {
    this.trustedPending = trustedPending
    this.untrustedPending = untrustedPending
    this.confirmed = confirmed
    this.spendable = spendable
    this.total = total
  }
}

/**
 * Block height and timestamp of a block
 */
export class BlockTime {
  /**
   * Confirmation block height
   */
  height: number | undefined

  /**
   * Confirmation block timestamp
   */
  timestamp: number | undefined

  constructor(height: number | undefined, timestamp: number | undefined) {
    this.height = height
    this.timestamp = timestamp
  }
}

/**
 * Fee Rate class
 */
export class FeeRate {
  _feeRate: number

  constructor(_feeRate: number) {
    this._feeRate = _feeRate
  }

  asSatPerVb(): number {
    return this._feeRate
  }
}
export class PubkeyHash {
  pubkeyHash: Array<number>
  constructor(hash: Array<number>) {
    this.pubkeyHash = hash
  }
}

export class ScriptHash {
  scriptHash: Array<number>
  constructor(hash: Array<number>) {
    this.scriptHash = hash
  }
}

export class WitnessProgram {
  program: Array<number>
  version: string
  constructor(program: Array<number>, version: string) {
    this.program = program
    this.version = version
  }
}

/**
 * Options for a software signer
 * Adjust the behavior of our software signers and the way a transaction is finalized
 */
export class SignOptions {
  /// Whether the provided transaction is a multi-sig transaction
  isMultiSig: boolean

  /// Whether the signer should trust the `witness_utxo`, if the `non_witness_utxo` hasn't been
  /// provided
  ///
  /// Defaults to `false` to mitigate the "SegWit bug" which should trick the wallet into
  /// paying a fee larger than expected.
  ///
  /// Some wallets, especially if relatively old, might not provide the `non_witness_utxo` for
  /// SegWit transactions in the PSBT they generate: in those cases setting this to `true`
  /// should correctly produce a signature, at the expense of an increased trust in the creator
  /// of the PSBT.
  ///
  /// For more details see: <https://blog.trezor.io/details-of-firmware-updates-for-trezor-one-version-1-9-1-and-trezor-model-t-version-2-3-1-1eba8f60f2dd>
  trustWitnessUtxo: boolean

  /// Whether the wallet should assume a specific height has been reached when trying to finalize
  /// a transaction
  ///
  /// The wallet will only "use" a timelock to satisfy the spending policy of an input if the
  /// timelock height has already been reached. This option allows overriding the "current height" to let the
  /// wallet use timelocks in the future to spend a coin.
  assumeHeight: number

  /// Whether the signer should use the `sighash_type` set in the PSBT when signing, no matter
  /// what its value is
  ///
  /// Defaults to `false` which will only allow signing using `SIGHASH_ALL`.
  allowAllSighashes: boolean

  /// Whether to remove partial signatures from the PSBT inputs while finalizing PSBT.
  ///
  /// Defaults to `true` which will remove partial signatures during finalization.
  removePartialSigs: boolean

  /// Whether to try finalizing the PSBT after the inputs are signed.
  ///
  /// Defaults to `true` which will try finalizing PSBT after inputs are signed.
  tryFinalize: boolean

  /// Whether we should try to sign a taproot transaction with the taproot internal key
  /// or not. This option is ignored if we're signing a non-taproot PSBT.
  ///
  /// Defaults to `true`, i.e., we always try to sign with the taproot internal key.
  signWithTapInternalKey: boolean

  /// Whether we should grind ECDSA signature to ensure signing with low r
  /// or not.
  /// Defaults to `true`, i.e., we always grind ECDSA signature to sign with low r.
  allowGrinding: boolean

  constructor(
    isMultiSig: boolean,
    trustWitnessUtxo: boolean,
    assumeHeight: number,
    allowAllSighashes: boolean,
    removePartialSigs: boolean,
    tryFinalize: boolean,
    signWithTapInternalKey: boolean,
    allowGrinding: boolean
  ) {
    this.isMultiSig = isMultiSig
    this.trustWitnessUtxo = trustWitnessUtxo
    this.assumeHeight = assumeHeight
    this.allowAllSighashes = allowAllSighashes
    this.removePartialSigs = removePartialSigs
    this.tryFinalize = tryFinalize
    this.signWithTapInternalKey = signWithTapInternalKey
    this.allowGrinding = allowGrinding
  }
}

export interface KruttCapacitorBDKPlugin {
  generateSeedFromWordCount(wordCount: WordCount): string
  generateSeedFromString(mnemonic: string): string
  generateSeedFromEntropy(entropy: Array<number>): string
  createDerivationPath(path: string): string
  createDescriptorSecret(network: Network, mnemonic: string, password?: string): string
  descriptorSecretDerive(id: string, derivationPathId: string): string
  descriptorSecretExtend(id: string, derivationPathId: string): string
  descriptorSecretAsPublic(id: string): string
  descriptorSecretAsSecretBytes(id: string): Array<number>
  descriptorSecretAsString(id: string): string
  createDescriptorPublic(id: string): string
  descriptorPublicDerive(id: string, derivationPathId: string): string
  descriptorPublicExtend(id: string, derivationPathId: string): string
  descriptorPublicAsString(id: string): string
  initElectrumBlockchain(
    url: string,
    sock5: string | null,
    retry: number,
    timeout: number,
    stopGap: number,
    validateDomain: boolean
  ): string
  initEsploraBlockchain(
    baseUrl: string,
    proxy: string | null,
    concurrency: number,
    stopGap: number,
    timeout: number
  ): string
  initRpcBlockchain(config: BlockchainRpcConfig): string
  getBlockchainHeight(id: string): number
  getBlockchainHash(id: string, height: number): string
  broadcast(id: string, txId: string): boolean
  estimateFee(id: string, target: number): number
  memoryDBInit(): string
  sledDBInit(path: string, treeName: string): string
  sqliteDBInit(path: string): string
  walletInit(
    descriptor: string,
    changeDescriptor: string | null,
    network: Network,
    dbConfig: string
  ): any
  getAddress(id: string, addressIndex: AddressIndex): any
  getInternalAddress(id: string, addressIndex: AddressIndex): any
  isMine(id: string, scriptId: string): boolean
  getBalance(id: string): Balance
  getNetwork(id: string): string
  sync(blockchain: string, id: string): boolean
  sign(id: string, psbtBase64: string, signOptions?: SignOptions): string
  listUnspent(id: string): Array<any>
  // TODO: Uncomment when figured out how to implement native `TransactionDetails`
  // listTransactions(id: string, includeRaw: boolean): Array<TransactionDetails>;
  initAddress(address: string): string
  addressFromScript(script: string, network: Network): string
  addressToScriptPubkeyHex(id: string): string
  addressPayload(id: string): Payload
  addressNetwork(id: string): string
  addressToQrUri(id: string): string
  addressAsString(id: string): string
  createTxBuilder(): string
  addRecipient(id: string, scriptId: string, amount: number): string
  finish(id: string, walletId: string): { base64: string; transactionDetails: any }
  addUnspendable(id: string, outPoint: OutPoint): boolean
  addUtxo(id: string, outPoint: OutPoint): boolean
  addUtxos(id: string, outPoints: Array<OutPoint>): boolean
  doNotSpendChange(id: string): boolean
  manuallySelectedOnly(id: string): boolean
  onlySpendChange(id: string): boolean
  unspendable(id: string, outPoints: Array<OutPoint>): boolean
  feeRate(id: string, feeRate: number): boolean
  feeAbsolute(id: string, feeRate: number): boolean
  drainWallet(id: string): boolean
  drainTo(id: string, scriptId: string): boolean
  enableRbf(id: string): boolean
  enableRbfWithSequence(id: string, nsequence: number): boolean
  addData(id: string, data: Array<number>): boolean
  // TODO: Uncomment when figured out how to implement native `ScriptAmount`
  // setRecipients(id: string, recipients: Array<ScriptAmount>): boolean;
  createDescriptor(descriptor: string, network: string): string
  descriptorAsString(id: string): string
  descriptorAsStringPrivate(id: string): string
  newBip44(id: string, keychain: KeychainKind, network: Network): string
  newBip49(id: string, keychain: KeychainKind, network: Network): string
  newBip84(id: string, keychain: KeychainKind, network: Network): string
  newBip44Public(id: string, fingerprint: string, keychain: KeychainKind, network: Network): string
  newBip49Public(id: string, fingerprint: string, keychain: KeychainKind, network: Network): string
  newBip84Public(id: string, fingerprint: string, keychain: KeychainKind, network: Network): string
  combine(psbt64: string, otherPsbt: string): string
  extractTx(psbt64: string): string
  serialize(psbt64: string): string
  txid(psbt64: string): string
  feeAmount(psbt64: string): number
  psbtFeeRate(psbt64: string): number
  jsonSerialize(psbt64: string): string
  bumpFeeTxBuilderInit(txid: string, newFeeRate: number): string
  bumpFeeTxBuilderAllowShrinking(id: string, address: string): string
  bumpFeeTxBuilderEnableRbf(id: string): any
  bumpFeeTxBuilderEnableRbfWithSequence(id: string, nsequence: number): any
  bumpFeeTxBuilderFinish(id: string, walletId: string): any
  createTransaction(bytes: Array<number>): string
  serializeTransaction(id: string): Array<number>
  transactionTxid(id: string): string
  txWeight(id: string): number
  txSize(id: string): number
  txVsize(id: string): number
  txIsCoinBase(id: string): boolean
  txIsExplicitlyRbf(id: string): boolean
  txIsLockTimeEnabled(id: string): boolean
  txVersion(id: string): number
  txLockTime(id: string): number
  txInput(id: string): Array<any>
  txOutput(id: string): Array<any>
  toBytes(id: string): Array<number>
}
